# 第一章	数据结构和算法的关系



## 1、数据结构和算法的介绍

> ​	数据结构和算法的介绍

- 数据 data 结构 ( structure ) 是一门研究组织数据方式的学科
- 程序 = 数据结构 + 算法
- 数据结构是算法的基础





## 2、线性结构

1. 线性结构是最常用的数据结构，特点是数据元素之间存在一对一的线性关系
2. 线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的( 地址连续 )
3. 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
4. 线性结构常见的有：数据、队列、链表和栈





## 3、 非线性结构

非线性结构包括：二维数组、多维数组、广义表、树结构、图结构



# 第二章	数组



## 1、稀疏数组

> ​	基本介绍

当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。





> ​	稀疏数组的处理方法是

1. 记录数组一共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20200817160610187](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200817160610187.png)



> ​	二维数组转稀疏数组

1. 遍历原始的二维数组，得到有效数据的个数 sum
2. 根据 sum 创建稀疏数组 Arr int[sum+1] [3]
3. 将二维数组的有效数据存入到稀疏数组



> ​	稀疏数组转原始二维数组

1. 先读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组
2. 再读取稀疏数组的后几行数据，并赋值给原始的二维数组



> ​	代码演示

```java
package day1;

import java.io.*;
import java.util.ArrayList;

/**
 * 稀疏数组
 */
public class Sparse {
    public static void main(String[] args) {
        //1、创建一个原始的二维数组 11 * 12
        int chessArr1[][] = new int[11][12];
        chessArr1[1][2] = 1 ;
        chessArr1[2][3] = 2 ;
        //输出原始的二维数组
        System.out.println("原始的二维数组");
        for (int [] arr : chessArr1){
            for (int s : arr){
                System.out.printf("%d\t",s);
            }
            System.out.println();
        }

        //2、将二维数组转换为稀疏数组
        //2.1 先遍历二维数组，找出非零的数的个数
        int sum = 0 ;
        for (int [] arr : chessArr1){
            for (int s : arr){
                if(s != 0){
                    sum++;
                }
            }
        }

        //3、创建对应的稀疏数组
        int sparseArr[][] = new int[sum+1][3];

        //4、给稀疏数组赋值
        //4.1 第一行赋值
        //行数
        sparseArr[0][0] = chessArr1.length;
        //列数
        sparseArr[0][1] = chessArr1[0].length;
        //值
        sparseArr[0][2] = sum;

        //4.2 遍历原始二维数组，将非 0 的值存放到 sparseArr 中
        int count = 0 ; //用于记录是第几个非 0 数据
        for(int i = 0 ; i < chessArr1.length ; i++){
            for (int j = 0 ; j < chessArr1[0].length ; j++){
               if(chessArr1[i][j] != 0){
                   count++;
                   sparseArr[count][0] = i;
                   sparseArr[count][1] = j ;
                   sparseArr[count][2] = chessArr1[i][j];
               }
            }
        }

        System.out.println("得到稀疏数组");
        for (int arr[] : sparseArr){
            System.out.printf("%d\t%d\t%d\t\n",arr[0],arr[1],arr[2]);
        }

        //5、将稀疏数组恢复成原始二维数组
        //5.1先读取第一行数据，创建出原始二维数组
        int  chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        //5.2 遍历稀疏数组将数据恢复到原始数组中
        for (int i = 1 ; i < sparseArr.length ; i++){
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }


        try {
            new Sparse().write(sparseArr,new File("D:/adb.txt"));
            int[][] arr = new Sparse().read(new File("D:/adb.txt"));

            System.out.println("++++++ 从硬盘中获得的稀疏数组 +++++++");
            for(int[] arr1 : arr){
                System.out.printf("%d\t%d\t%d\n",arr1[0],arr1[1],arr1[2]);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * 将稀疏数组写入到磁盘中
     * @param arr 稀疏数组
     * @param file 文件
     * @throws IOException
     */
    public void write(int arr[][], File file) throws IOException {
        FileWriter writer = new FileWriter(file);

        //遍历稀疏数组
        for (int obj[] : arr){
            char[] cs = (obj[0] + " " + obj[1] + " " + obj[2]+"\n").toCharArray();
            writer.write(cs);
            writer.flush();
        }
        writer.close();
    }

    /**
     * 读取稀疏数组
     * @param file 读取的文件
     * @return 返回稀疏数组
     * @throws IOException
     */
    public int[][] read(File file) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(file));
        ArrayList<int[]> list = new ArrayList<>();
        //读取剩下的行并给稀疏数组赋值
        for (int i = 1 ; true ; i++){
            String str2 = reader.readLine();
            if (str2 == null){
                break;
            }
            String[] str1 = str2.split(" ");
            int [] result = new int[3];
            result[0] = Integer.parseInt(str1[0]);
            result[1] = Integer.parseInt(str1[1]);
            result[2] = Integer.parseInt(str1[2]);
            list.add(result);
        }
        reader.close();
        //创建二维数组
        int [][] result = new int[list.size()][3];
        int i = 0 ;
        //将链表里的数据复制到稀疏数组中
        for (int [] l : list){
            result[i++] = l;
        }
        return result;

    }

}
```





# 第三章	队列



## 1、数组模拟环形队列

> ​	介绍

- 队列是一个有序列表，可以用数组或是链表来实现
- 遵循先入先出的原则



> ​	数组模拟环形队列思路分析

1. front ：队列的第一个元素，初始值为 0
2. rear：队列的最后一个元素的后一个位置，留出一个空间不用，初始值为 0
3. 队列满的条件：( rear +1 ) % maxSize == front
4. 队列为空的条件：rear == from
5. 队列中有效数据的个数 ( rear + maxSize - front ) % maxSize 



> ​	数组模拟环形队列代码演示

```java
/**
 * 环形数组模拟队列
 */
public class CirclArray {
    private int maxSize ; //数组的最大容量

    //front指向队列的第一个元素，默认值是 0
    private int front ;

    //指向队列的最后一个元素的后一个位置，默认值是0
    private int rear ;

    //存放数据的模拟队列
    private int[] arr ;

    /**
     * 构造函数
     * @param maxSize 队列的长度，会留出一个不用
     */
    public CirclArray(int maxSize){
        this.maxSize = maxSize + 1 ;
        arr = new int[this.maxSize] ;
    }

    /**
     * 判断队列是否已满
     * @return
     */
    public boolean isFull(){
        return (rear + 1) % maxSize == front ;
    }

    /**
     * 判断队列是否为空
     * @return
     */
    public boolean isEmpty(){
        return rear == front ;
    }

    /**
     * 添加数据
     * @param data
     */
    public void add(int data) {
        //判断队列是否已满
        if (isFull()){
            throw new RuntimeException("队列已满，无法添加");
        }
        //添加数据
        arr[rear] = data ;
        //将 rear 后移，rear 有可能已经是数组的最后一个了，需要考虑取模，再次从头开始
        rear = (rear + 1) % maxSize ;
    }

    /**
     * 取出数据，出队列
     * @return
     */
    public int get(){
        //判断队列是否为空
        if (isEmpty()){
            throw  new RuntimeException("队列为空，无法取出数据");
        }
        //取出数据：必须先将数据保存到临时变量，不然front移动后无法获取数据
        int value = arr[front] ;
        front = (front +1) % maxSize ;
        return value;
    }
    
     /**
     * 查看队列第一个数据，不是取出
     * @return
     */
    public int peep(){
        //判断队列是否为空
        if (isEmpty()){
            throw  new RuntimeException("队列为空");
        }
        return arr[front];
    }

    /**
     * 显示队列中的全部数据
     */
    public void show(){
        //判断队列是否为空
        if (isEmpty()){
            System.out.println("队列为空");
        }
        for (int i = front ; i < front + size() ; i++){
            System.out.printf("arr[%d] = %d\n",i % maxSize , arr[i % maxSize]);
        }
    }

    /**
     * 返回队列有效数据的个数
     * @return
     */
    public int size(){
        return (rear + maxSize - front ) % maxSize ;
    }
}

```



## 2、单链表模拟队列

参考下方单向链表





# 第四章	链表

## 1、单向链表



> ​	单向链表反转

```java
package day1;

/**
 * 单向链表反转
 */
public class LinkedReversal {
    public static void main(String[] args) {
        NodeList list = new NodeList();
        for(int i = 1 ; i < 9 ; i++){
            list.add(new Node(i+""));
        }
        list.show();
        list.reversal();
        System.out.println();
        list.show();

    }

}

class NodeList{
    private Node head;

    public NodeList(){
        this.head = new Node();
    }

    /**
     * 添加节点
     * @param newNode
     */
    public void add(Node newNode){
        Node temp = head;
        while (temp.next != null){
            temp = temp.next;
        }
        temp.next = newNode;
    }

    /**
     * 输出所有结点
     */
    public void show(){
        Node temp = head;
        while (temp.next != null){
            System.out.println(temp.next.name);
            temp = temp.next;
        }
    }

    /**
     * 单向链表结点反转
     */
    public void reversal(){
        //临时结点
        Node temp = head.next;
        //新头结点
        Node newHead = new Node();

        while (head.next != null){
            //保存2号结点
            temp = head.next;
            //头结点指向3号结点
            head.next = temp.next;

            //这时候2号结点拿出来不会丢失结点
            //将2号结点拿出来接在新头结点后面
            if(newHead.next != null){ //当新头结点后面有结点时
                temp.next = newHead.next;
            }else{
                //新头结点之后没有结点，temp也就是源链表除头结点外的第一个结点，
                //将这个结点指向空
                temp.next = null;
            }
            newHead.next = temp;
        }
        head = newHead;


    }

}

/**
 * 节点
 */
class Node{
    String name;
    Node next;

    public Node(){}

    public Node(String name){
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}
```



> ​	单向链表逆向打印

**方法一**：

​		将链表保存到栈中，利用栈的先进后出特点实现



## 2、双向链表





## 3、环形链表(约瑟夫问题)

> ​	约瑟夫问题

Josephu 问题：设编号为1、2、3...的 n 个人围成一圈，约定编号为 k（1 <= k <= n）的人从 1 开始报数，数到 m 人出列，然后他的下一位又从 1 开始报数，数到 m 的人又出来，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。



> 约瑟夫问题解题思路	

1. 新建一个临时结点指向头结点
2. 如果 k 不为 1，先移动到指定 k 结点（ while 循环 ）
3. 循环 m -1 遍，每次循环，临时结点指向自己的下一个（ temp.next = temp.next.next ）
4. 再次新建一个临时结点，保存好临时结点的下一个结点（ newtemp = temp.next.next ）
5. 临时结点指向的结点指向下下个结点（ temp.next.next =  temp.next.next.next ）
6. 将新临时结点保存到新链表中
7. 当链表只剩下一个时，直接保存到新链表中（ temp.next.next == temp.next ）
8. 继续循环





# 第五章	栈

## 1、介绍

1. 栈的英文是 ( stack )
2. 栈是一个**先入后出**的有序列表
3. 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊的线性表。允许插入和删除的一端称为**栈顶**，另一端称为**栈底**。
4. 最先放入栈中的元素在栈底，最后放入的元素在栈顶，最后放入的元素先删除，最先放入的元素后删除。





## 2、数组模拟栈

1. 定义一个 top 来表示栈顶，初始化为 -1
2. 入栈操作，添加数据到栈是，top ++，stack [ top ] = data ;
3. 出栈操作， return stack [ top-- ] ;  

```java
package stack;

/**
 * 数组模拟栈
 */
public class MyStack {
    private int top = -1;
    private int[] stack;

    /**
     * 返回当前栈顶的位置
     * @return
     */
    public int getTop() {
        return top;
    }

    /**
     * 栈的最大深度(从0开始)
     * @return
     */
    public int getSize(){
        return stack.length-1;
    }


    /**
     * @param size 栈的大小
     */
    public MyStack(int size){
        if(size < 1){
            throw new RuntimeException("栈的深度小于1");
        }
        this.stack = new int[size];
    }

    /**
     * 入栈
     * @param data 数据
     */
    public void push(int data){
        if (isFull()){
            throw new RuntimeException("栈满，不能添加数据");
        }
        stack[++top] = data;
    }

    /**
     * 出栈
     * @return
     */
    public int pop(){
        if (isEmpty()){
            throw new RuntimeException("栈空，不能出栈");
        }
        return stack[top--];
    }

    /**
     * 判断栈是否已满
     * @return
     */
    public boolean isFull(){
        //当栈顶为数组最大下标时表示栈满
        if (top+1 == stack.length){
            return true;
        }
        return false;

    }

    /**
     * 栈是否为空
     * @return
     */
    public boolean isEmpty(){
        if (top == -1){
            return true;
        }
        return false;
    }

    /**
     * 显示当前栈的使用情况
     */
    public void show(){
        for (int i = top ; i >= 0 ; i--){
            System.out.println(stack[i]);
        }
    }

}
```





## 3、单链表模拟栈

```java
package stack;

/**
 * 单向链表实现栈
 */
public class MyStack2 {
    private int size = 0; // 当前栈内数据的个数
    private Node top = new Node();


    /**
     * 返回当前栈内数据的个数
     * @return
     */
    public int getSize() {
        return size;
    }

    /**
     * 入栈
     * @param data
     */
    public void push(String data){
        Node node = new Node(data);
        if (!isEmpty()){
            //top.next 指向栈顶结点
            node.next = top.next;
        }
        top.next = node;
        //栈的深度加1
        size++;
    }

    /**
     * 出栈
     * @return
     */
    public String pop(){
        if (isEmpty()){
            throw new RuntimeException("栈空，不能出栈");
        }
        size--;
        //临时结点保存将要出栈的结点
        Node node = top.next;
        //让栈顶结点指向上一个结点(距离栈底更近的结点)
        top.next = node.next;

        return node.data;
    }

    /**
     * 判断栈是否为空
     * @return
     */
    public boolean isEmpty(){
        if(size == 0){
            return true;
        }
        return false;
    }

    /**
     * 显示栈的数据
     */
    public void show(){
        Node node = new Node();
        //临时结点指向栈顶的额结点
        node.next = top.next;
        while (true){
            //输出临时结点指向的结点的数据，临时结点的data是null
            System.out.println(node.next);
            if (node.next.next == null){
                break;
            }
            node.next = node.next.next;
        }
    }



}

class Node{
    String data;
    Node next;

    public Node(){}

    public Node(String name){
        this.data = name;
    }

    @Override
    public String toString() {
        return data;
    }
}

```



## 4、使用栈完成简单计算器

> 解题思路

1. 创建两个栈，一个用来存数字，一个用来存储符号
2. 使用一个 index 来遍历字符串
3. 如果是数字，直接入数字栈
4. 如果是符号
   1. 如果符号栈为空，直接入栈
   2. 如果当前运算符优先级小于或者等于栈中操作符，则从数字栈中出栈两个数字，符号栈中出栈一个符号进行运算，得到的结果入数字栈，当前运算符入符号栈
   3. 如果当前运算符优先级大于栈中操作符，直接入栈
5. 扫描完毕时，顺序从数栈和符号栈中出栈数字和符号进行运算
6. 数栈最后一个数字就是结果



**小结**

​	简单说就是当前是符号，如果两个符号是同乘除或同加减，或者当前是加减，上一个是乘除，就先算完上一个





## 5、前缀、中缀、后缀表达式

### 1）前缀表达式

> ​	介绍

​	前缀表达式又称波兰表达式、波兰式。**前缀表达式的运算符位于操作数之前。**



> ​	前缀表达式的计算机求值

​	**从右至左扫描**表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶两个数，用运算符对它们做相应的运算，并将结果入栈；重复上述过程直到表达式的最左端，最后运算得出的值即为表达式的结果



**例如**：(3+4) * 5 - 6 对应的前缀表达式就是 - * + 3 4 5 6，针对前缀表达式求值步骤如下

1. 从右至左扫描，将 6、5、4、3 压入栈中
2. 遇到 + 运算符，弹出 3 和 4 ( 3 为栈顶元素，4 为次顶元素 )，计算出 3 + 4 的值，得 7，将 7 压入栈中
3. 接下来是 * 运算符，因此弹出 7 和 5 ，计算出 7 * 5 = 35，将 35 入栈
4. 最后是 - 运算符，计算出 35 - 6 = 29，这是栈中最后一个元素，也就是结果



### 2）中缀表达式

> ​	介绍

1. 中缀表达式就是最常见的运算表达式，如 ( 3 + 4 ) * 5 - 6
2. 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其他表达式来操作（ 一般转成后缀表达式 ）





### 3）后缀表达式

> ​	介绍

1. 后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后
2. 举例：( 3+4 ) * 5 - 6 对应的后缀表达式就是 3 4 + 5 * 6 -



> ​	后缀表达式的计算机求值

​		**从左至右**扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈；重复上述过程指导表达式最右端，最后运算得出的值即为表达式的结果。

> ​	例如

( 3+4 ) * 5 -6 对应的后缀表达式是 3 4 + 5 * 6 - ，针对后缀表达式求值步骤如下：

1. 从左至右扫描，将 3 和 4 压入堆栈；
2. 遇到 + 运算符，弹出 4 和 3 ( 4 为栈顶元素，3 为次顶元素 )，计算出 3+4 的值，再将 7 入栈
3. 将 5 入栈
4. 遇到 * 运算符，弹出 7 和 5，将 35 入栈
5. 将 6 入栈
6. 最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果



### 4）中缀转前缀、后缀

1. ​	在不破坏表达式本身的运算优先级的前提下可以给所有表达式加上括号
   1. 例如：( a+b ) * c + d - ( e+g ) * h
      1. 加上括号：( ( ( ( a+b ) * c ) +d )-( ( e + g ) * h ))
      2. 前缀表达式：- + * + a b c d * + e g h
      3. 后缀表达式：a b + c * d + e g + h * -
2. 如果是转前缀表达式，就将括号内的符号提到括号前面
3. 如果是转后缀表达式，就将括号内的运算符提到括号后面



**注意**：不能更改原来的运算顺序



### 5）代码实现中缀转后缀

> ​	实现思路

1、初始化两个栈：运算符栈 s1 和存储中间结果的栈 s2

2、从左至右扫描中缀表达式

3、遇到数字时，直接压入 s2

4、遇到运算符时，和 s1 栈顶运算符比较优先级

​		4.1  如果 s1 为空，或栈顶运算符为左括号，或者优先级比 s1 栈顶元素高，直接将其入 s1 栈

​		4.2  否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次跳转到 4.1 与 s1 中新的栈顶元素比较

5、遇到括号时

​		5.1  如果是左括号，直接压入 s1

​		5.2  如果是右括号，依次弹出 s1 栈顶的运算符并压入 s2，直到遇到左括号位置，此时，这一对括号丢弃

6、重复步骤 2 ~ 5，直到表达式扫描完毕

7、将 s1 中剩余的运算符依次弹出并压入 s2

8、依次弹出 s2 中的元素，结果的逆序就是中缀表达式对应的后缀表达式



> 表格步骤分析

中缀表达式：1+ ( ( 2 + 3 ) * 4 ) - 5

| 扫描到的元素 | s1( 栈底->栈顶 ) | s2( 栈底->栈顶 )  | 说明                                                         |
| ------------ | ---------------- | ----------------- | ------------------------------------------------------------ |
| 1            | 空               | 1                 | 数字直接入栈 s2                                              |
| +            | +                | 1                 | s1为空，运算符直接入栈 s1                                    |
| (            | +（              | 1                 | 左括号直接入栈 s1                                            |
| (            | +（（            | 1                 | 同上                                                         |
| 2            | +（（            | 1 2               | 数字                                                         |
| +            | +（（ +          | 1 2               | s1 栈顶为左括号，运算符直接入栈                              |
| 3            | +（（ +          | 1 2 3             | 数字                                                         |
| )            | +（              | 1 2 3 +           | 右括号，依次弹出 s1 运算符压入 s2，直到遇到左括号            |
| *            | +（ *            | 1 2 3 +           | s1 栈顶左括号，运算符直接入栈 s1                             |
| 4            | +（ *            | 1 2 3 + 4         | 数字                                                         |
| )            | +                | 1 2 3 + 4 *       | 右括号，依次弹出 s1 运算符压入 s2，直到遇到左括号            |
| -            | -                | 1 2 3 + 4 * +     | 未比 s1 栈顶运算符优先级高，弹出 s1 中栈顶运算符压入 s2，再次与 s1 中栈顶元素比较 |
| 5            | -                | 1 2 3 + 4 * + 5   | 数字                                                         |
| 到达最右端   |                  | 1 2 3 + 4 * + 5 - | 将 s1 中元素依次弹出并压入 s2                                |

依次弹出 s2 中元素，逆序输出就是对应中缀表达式的后缀表达式：1 2 3 + 4 * + 5 -









## 6、逆波兰计算器

```java
package stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * 逆波兰表达式计算机
 */
public class Reverse {

    public static void main(String[] args) {
        String infix = "1+((2+3)*4)-5";
        //将中缀表达式转换成 ArrayList
        List<String> list = getInfixList(infix);

        //将中缀表达式转换成后缀表达式
        list = getSuffixList(list);
        //使用逆波兰计算机计算数值
        System.out.println(getResult(list));

    }


    /**
     * 将中缀表达式转换为 ArrayList
     * @param infix 中缀表达式
     * @return
     */
    public static List<String> getInfixList(String infix){
        //定义一个 List 存放中缀表达式的 ArrayList
        List<String> list = new ArrayList<String>();
        int i = 0; //遍历字符串，保存字符串下标
        String tmp; //当数字是多位数时拼接
        char c ;//遍历的字符存储到 c
        do {
            //如果遍历到的 c 是一个符号，直接添加到 list
            if ((c = infix.charAt(i)) < 48 || (c = infix.charAt(i)) > 57){
                list.add(c+"");
                i++;
            }else { //如果不是符号，需要考虑多位数
                tmp = "" ; //每次使用的时候，赋值为空
                while (i < infix.length() && (c = infix.charAt(i)) >= 48 && (c = infix.charAt(i)) <= 57){
                    tmp += c ; //拼接
                    i++;
                }
                list.add(tmp);
            }
        }while (i < infix.length());

        return list;
    }

    /**
     * 将后缀表达式分割成 ArrayList
     * @param suffixExpression 后缀表达式
     * @param regex 分割的正则匹配规则
     * @return
     */
    public static List<String> getSuffixList(String suffixExpression, String regex){
        //将后缀表达式分割成ArrayList
        String[] strList = suffixExpression.split(regex);
        List<String> list = new ArrayList<String>();

        for (String itm : strList){
            list.add(itm);
        }
        return list;
    }

    /**
     * 将中缀表达式转换为后缀表达式
     * @param list 中缀表达式
     * @return
     */
    public static List<String> getSuffixList(List<String> list){
        Stack<String> s1 = new Stack<String>();
        Stack<String> s2 = new Stack<String>();
        for (String tmp : list){
            //Character.isDigit(tmp.charAt(0))：如果tmp是数字，返回true
            if (Character.isDigit(tmp.charAt(0))){
                //如果是数字，直接入栈 s2
                s2.push(tmp);
            }else if (tmp.equals("+") || tmp.equals("-") || tmp.equals("*") || tmp.equals("/")){
                //如果 tmp 是运算符

                boolean res = true; //判断 tmp 是否不比 s1 栈顶元素优先级高

                while (res){
                    //如果 s1 为空，或者 s1 栈顶元素为左括号，直接入栈 s1
                    if (s1.isEmpty() || s1.peek().equals("(")){
                        s1.push(tmp);
                        res = false; // tmp 已经入栈，不需要继续比较了
                    }else if (Operation.getPriority(tmp) > Operation.getPriority(s1.peek())){

                        //如果 tmp 运算优先级比 s1 栈顶元素高，直接入栈 s1
                        s1.push(tmp);
                        res = false; // tmp 已经入栈，不需要继续比较了
                    }else {
                        //否则，将 s1 栈顶元素弹出并入栈 s2，tmp 继续和 s1 栈顶元素比较
                        s2.push(s1.pop());
                    }
                }

            }else if (tmp.equals("(")){
                //如果 tmp 是左括号，直接入栈 s1
                s1.push(tmp);
            }else if(tmp.equals(")")){
                //如果是右括号，依次弹出 s1 栈顶元素并压入 s2，直到遇到左括号
                String s ;
                while (!(s = s1.pop()).equals("(")){
                    s2.push(s);
                }
                
            }
        }
        //这时候 ArrayList 已经遍历完了
        //将 s1 中剩余的运算符依次弹出并压入 s2
        while (!s1.isEmpty()){
            s2.push(s1.pop());
        }
        //将 s2 中所有数据压入 s1 ，然后在从 s1 中依次弹出，达到逆序输出的结果
        while (!s2.isEmpty()){
            s1.push(s2.pop());
        }
        List<String> list1 = new ArrayList<String >();
        while (!s1.isEmpty()){
            list1.add(s1.pop());
        }


        return list1;


    }



    /**
     * 后缀表达式运算
     * @param list 后缀表达式
     * @return
     */
    public static int getResult(List<String> list){
        //创建一个栈保存数据
        Stack<String> stack = new Stack<String>();
        //遍历 list
        for (String item : list){
            //使用正则来匹配是数字还是字符
            if (item.matches("\\d+")){
                //如果是数字，直接入栈
                stack.push(item);
            }else {
                //如果是运算符，pop 出两个数据，进行运算
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int result = 0;

                if(item.equals("+")){
                    result = num1 + num2;
                }else if (item.equals("-")){
                    //注意，是次顶数减去栈顶数
                    result = num1 - num2;
                }else if (item.equals("*")){
                    result = num1 * num2;
                }else if (item.equals("/")){
                    result = num1 / num2 ;
                }else {
                    //整数运算，如果出现其他字符，直接抛出异常
                    throw new RuntimeException("出现出 + — * / 之外的符号");
                }
                //将运算结果入栈
                stack.push(result + "");

            }
        }
        return Integer.parseInt(stack.pop());

    }

}

/**
 * 类的优先级分辨
 */
class Operation{

    /**
     * 返回运算符的优先级
     * @param operation 运算符(单个)
     * @return
     */
    public static int getPriority(String operation){
        switch (operation){
            case "*":
            case "/":
                return 12;
            case "+":
            case "-":
                return 11;
        }
        return 0;
    }

}

```









# 第六章	递归

## 1、递归需要遵守的规则

- 执行一个方法是，就创建一个新的受保护的独立空间 ( 栈空间 )
- 方法的局部变量时独立的，不会相互影响
- 递归必须向退出递归的条件逼近，否则就是无限递归，就会出现死龟现象 ( StackOverflowError )
- 当一个方法执行完毕或者遇到 return 就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。





## 2、递归迷宫问题

```java
package recursion;

/**
 * 递归回溯问题
 */
public class traceback {
    /**
     * 地图约定：0 表示未走过，1 表示墙，2 表示已经走过，3 表示死路
     * @param args
     */

    public static void main(String[] args) {
        //初始化一个二维数组
        int[][] map = new int[8][7];
        initialize(map);
        count(map,1,1,1,2);
        show(map);
    }

    /**
     * 给迷宫制造障碍
     * @param map 迷宫地图
     */
    public static void initialize(int[][] map){
        if(map == null){
            throw new RuntimeException("二维数组为空");
        }
        //初始化上下的墙
        for (int i = 0 ; i < map[0].length ; i++){
            map[0][i] = 1 ;
            map[map.length-1][i] = 1;
        }
        //初始化左右的墙
        for (int i = 0 ; i < map.length ; i++){
            map[i][0] = 1 ;
            map[i][map[i].length-1] = 1;
        }

        //添加障碍
        map[3][1] = 1 ;
        map[3][2] = 1 ;
    }

    /**
     * 使用递归回溯找路（策略：下右上左）
     * @param map 地图
     * @param startRow 开始行坐标
     * @param startCol 开始列坐标
     * @param endRow 结束行坐标
     * @param endCol 结束列坐标
     * @return
     */
    public static boolean count(int[][] map, int startRow, int startCol,int endRow,int endCol){
        //正确路线已经找到
        if (map[endRow][endCol] == 2){
            return true;
        }
        //还未找到正确路线，继续寻找
        //当 map[startRow][startCol] 还没走过
        if (map[startRow][startCol] == 0){
            //按照策略 下右上左 走
            //先假设这个点是可以行走的
            map[startRow][startCol] = 2 ;

            if (count(map,startRow+1,startCol,endRow,endCol)){ //向下走
                //count 返回 true，证明可以走通
                return true ;
            }else if (count(map,startRow,startCol+1,endRow,endCol)){ //向右走
                return true;
            }else if (count(map,startRow-1,startCol,endRow,endCol)){ //向上走
                return true;
            }else if (count(map,startRow,startCol-1,endRow,endCol)){ //向左走
                return true;
            }else {
                //如果都走不通，证明这点是死路
                map[startRow][startCol] = 3 ;
                return false;
            }

        }else {
            //如果 map[startRow][startCol] != 0，这条路不能走
            return false;
        }

    }



    /**
     * 输出迷宫地图（二维数组）
     * @param map
     */
    public static void show(int[][] map){
        for (int[] tmp : map){
            for (int i : tmp){
                System.out.print(i+" ");
            }
            System.out.println();
        }

    }

}
```



## 3、八皇后问题（回溯算法）

### 1）问题介绍

​		八皇后问题是由国际西洋棋棋手 马克思 · 贝瑟尔 于 1848 年提出：在 8 * 8 的国际象棋上摆放八个皇后，使其不能相互攻击。即：任意两个皇后都不能处于同一行、同一列 或 同一斜线上，问，有多少中摆法 ？



### 2）代码实现

```java
package recursion;

/**
 * 八皇后问题
 */
public class Queen {

    //皇后的数量
    public static int max = 8 ;
    static int[] arr = new int[max];

    public static void main(String[] args) {
        check(0);
    }


    /**
     * 放置皇后
     * @param n 第几个皇后
     */
    public static void check(int n){
        if (n == 8){ //因为 n 从 0 开始，当 n = 8 时，已经放置了 8 个皇后
            show();
            return;
        }

        //依次从第 0 列开始放置，直到最后一列
        for (int i = 0 ; i < max ; i++){
            arr[n] = i ;
            //result(n) == true 是第 n 个皇后和之前的皇后冲突
            if (!result(n)){ //不冲突
                //所以进入这里是不发生冲突

                //如果不发生冲突，递归调用这个方法再次判断
                //如果发生冲突，不作为，也就是继续 for 循环，将第 n 个皇后放到本行下一个位置，也就是后一个
                check(n+1);
            }

        }

    }

    public static void show(){
        for (int tmp : arr){
            System.out.print(tmp+" ");
        }
        System.out.println();
    }

    /**
     * 判断第 n 个皇后是否和之前的皇后冲突
     * @param n
     * @return true：冲突 false：不冲突
     */
    public static boolean result(int n){
        for (int i = 0 ; i < n ; i++){
            //arr[n] == arr[i] 判断第 n 个和第 i 个皇后是否在同一列
            /**
             *  Math.abs(n-i) == Math.abs(arr[n]-arr[i]) 在同一斜线
             *  n-i 的绝对值可以理解和（0,0）的行距离（竖着的距离）
             *  arr[n]-arr[i] 是和（0,0）的列距离（横着的距离）
             *  举例：a[5] = 6,a[4] = 5
             *  n-i 的绝对值距离 (0,0) 1 个单位
             *  6-5 的绝对值距离（0,0）1 个单位长度
             *  所以 a[5] = 6,a[4] = 5 ,在同一斜线上
             */
            if(arr[n] == arr[i] || Math.abs(n-i) == Math.abs(arr[n]-arr[i])){
                return true;
            }
        }
        return false;
    }

}
```





# 第七章	排序算法



## 1、排序算法简介

### 1、介绍

​		（ Sort Algorithm ），排序是将一组数据依照指定的顺序进行排列的过程。



### 2、排序的分类

- 内部排序
  - 将需要处理的所有数据都加载到内部存储器中进行排序
- 外部排序
  - 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序

![image-20200831164251235](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200831164251235.png)





### 3、算法的时间复杂度

> ​	1、事后统计的方法

​		这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得的时间的统计量依赖于计算机的硬件、软件等环境因素，**这种方式，要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。**



> ​	2、事前估算的方法

​		通过分析某个算法的时间复杂度来判断哪个算法更优。



#### 1）时间频度

> 基本介绍

​		一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费的时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记为 T (n)





### 4、算法的空间复杂度

#### 1）基本介绍

- 类似于时间复杂度的讨论，一个算法的空间复杂度 ( Space Complexity ) 定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。
- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序就属于这种情况。
- 在做算法分析时，主要讨论的是时间复杂度。从用户体验上看，更看重程序执行的速度。**一些缓存产品 ( Redis，memcache ) 和算法 ( 基数排序 ) 本质上就是用空间换时间**。





## 2、冒泡排序

### 1）基本介绍

​		冒泡排序 ( Bubble Sorting ) 的基本思想是：通过对待排序序列从前向后 ( 从下标较小的元素开始 )，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。



​		因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。



### 2）动画演示

![image](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY)







### 3）代码实现

```java
package sort;

import java.util.Arrays;
import java.util.Random;

/**
 * 冒泡排序
 * 冒泡排序的时间复杂度：O(n^2)
 * 10000个数据 200ms
 */
public class Bubbling {

    public static void main(String[] args) {
        int[] arr = getArray(20);
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static  void sort(int[] arr){
        int ss = 0 ;
        boolean flag ;
        for (int i = 0 ; i < arr.length-1 ; i++){
            //为了效率考虑，定一个变量判断，如果这个数组已经有序了，就不需要再排序了
            flag = true ;
            for (int j = 0 ; j < arr.length-i-1 ; j++){
                ss++;
                if(arr[j] > arr[j+1]){ //顺序排序，如果前面的比后面的大，前后交换
                    flag = false;
                    //前后交换
                    arr[j] += arr[j+1];
                    arr[j+1] = arr[j] - arr[j+1];
                    arr[j] -= arr[j+1];
                }
            }
            //如果 flag==true，证明一次交换都没有，也就是说这个队列是有序的，不需要交换
            if (flag){
                break;
            }
        }
        System.out.println(ss);
    }

    /**
     * 创建一个一维数组并填充随机数
     * @param size 数组长度
     * @return
     */
    public static int[] getArray(int size){
        int[] arr = new int[size];
        Random random = new Random();
        for (int i = 0 ; i < size ; i++){
            arr[i] = random.nextInt(size*10);
        }
        return arr;
    }

}
```





## 3、选择排序

### 1）基本介绍

​		选择排序（**Selection-sort**）也属于内部排序法，是从源数组的数据中，按指定的规则选出某一个元素，再依规定交换位置后达到排序的目的。

​	

### 2）实现思想

​		遍历一次，记住最小 / 最大值的坐标然后和最前面的数依次交换。



### 3）动画演示

![image](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjQ3MTk1OTAtMTQzMzIxOTgyNC5naWY)





### 4）代码实现

```java
package sort;

import java.util.Arrays;

/**
 * 选择排序
 * 10000 个数据 70 ms
 * 十万个数据花费时间大概为冒泡的 1/3
 */
public class Select {

    public static void main(String[] args) {
        //使用了 冒泡排序随机的数组
        int[] arr = Bubbling.getArray(10);
        System.out.println("排序前："+Arrays.toString(arr));
        sort(arr);
        System.out.println("排序后："+Arrays.toString(arr));
    }

    public static void sort(int[] arr){
        int minIndex; //记住最小值的下标
        for (int i = 0 ; i < arr.length-1 ; i++){
            minIndex = i ;
            for ( int j = i+1 ; j < arr.length ; j++ ){
                //如果后面的值有比当前最小值还小的，保存更小的那个
                if (arr[minIndex] > arr[j]){
                    minIndex = j ;
                }
            }
            //当最小值下标和原来的下标不一致时才需要交换
            if (minIndex != i){
                arr[minIndex] += arr[i];
                arr[i] = arr[minIndex] - arr[i];
                arr[minIndex] -= arr[i];
            }

        }
    }
}
```





## 4、插入排序

### 1）实现思想

​		插入排序 ( Insertion Sorting ) 的基本思想是：把 n 个待排序的元素看成一个有序和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n -1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。



### 2）动画演示

![image](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY)





### 3）代码实现

```java
package sort;

import java.util.Arrays;

/**
 * 插入排序
 * 10000个数据 22ms
 */
public class Insertion {

    public static void main(String[] args) {
        //获取一个随机数组
        int[] array = Bubbling.getArray(100000);
        long start = System.currentTimeMillis();
        sort(array);
        System.out.println("花费时间："+(System.currentTimeMillis()-start)+" ms");
        System.out.println(Arrays.toString(array));

    }

    /**
     * 选择排序
     * @param arr 源数组
     */
    public static void sort(int[] arr){
        //n 用来遍历当前是第几个数据，也是数组的下标
        for (int n = 1 ; n < arr.length ; n++){
            //保存待插入数值
            int insertValue = arr[n];
            //保存待插入下标，
            int insertIndex = n-1;

            //insertIndex >= 0 保证 insertIndex 不会越界
            //insertValue <= arr[insertIndex] 当待插入数值比 arr[insertIndex] 也就是比前面的数小时，才有继续查找的必要
            while (insertIndex >= 0 && insertValue <= arr[insertIndex]){
                //如果进入到了这，证明当前数值肯定比待插入数值大，这时我们将当前数据往后移
                arr[insertIndex+1] = arr[insertIndex];
                insertIndex--;
            }
            //经过上面的循环过后，会有两种正常情况，insertIndex = -1，或者 arr[insertIndex] 的值比待插入值小或者相等
            //insertIndex+1 就是待插入数据的下标
            arr[insertIndex+1] = insertValue;

        }
    }

}
```





## 5、希尔排序

### 1）介绍

​		希尔排序是希尔 ( Donald Shell ) 于 1959 年提出的一种算法。希尔排序也是一种**插入排序**，它是简单插入排序经过改进之后的一个**更高效的版本**，也称为**缩小增量排序**。



### 2）基本思想

​		希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量的逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。



### 3）实现思路



源数组：元素颜色相同为同一组，假设这个数组为 arr

![image-20200902081237155](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200902081237155.png)







第一轮：初始增量  gap = arr.length / 2 = 5，意味着整个数组被分为了 5组，相同颜色的为一组，然后同组进行插入排序

![image-20200902081302620](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200902081302620.png)



这时候我们发现部分小元素已经被调到前面了；

第二轮：增量为 gap = gap /2 = 2 (向下取整)，这时候整个 arr 被分为了 2组，每组进行插入排序

![image-20200902081349867](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200902081349867.png)



这时候 arr 更加接近有序数组了；

第三轮：再次缩小增量 gap = gap /2 = 1 当 gap 为 1 时，整个数组被分为了一组，这时候再次进行插入的时候就不容易出现 “ 特别小 ” 的值在最后而引起大量元素后移的情况。

![image-20200902081415242](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200902081415242.png)





当 gap =1 运行完后，arr 数组已经是一个有序数组了

最后结果：当 gap = 0 时就可以退出循环了，gap = 0 不需要运行。

![image-20200902081435640](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200902081435640.png)





### 4）代码实现

```java
package sort;

import java.util.Arrays;

/**
 * 希尔排序
 */
public class Shell {
    public static void main(String[] args) {
        int[] arr = Bubbling.getArray(100);
        //int[] arr = {8,9,1,7,2,3,5,4,6,0};
        shellSort(arr);
        //shellSort2(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 希尔排序：交换法
     * 思想：待插入的一次次和前一个比较，如果待插入数比前面的小，待插入元素和前一个元素交换位置，然后继续比较，直到待插入元素比前一个元素大，或者前面无元素
     * @param arr 源数组
     */
    public static void shellSort(int[] arr){
        
        int tmp;

        //gap 增量，每次为上一次增量的一半，向下取整
        //这个循环是确定增量，拆分 arr 的
        //gap > 0 当 gap = 1 时，arr 就只有一组，排完之后就已经是有序数组了
        for (int gap = arr.length /2 ; gap > 0 ; gap /= 2){

            //这个循环遍历的是 arr 的小数组：这里遍历的是小数组
            //i++,这个遍历是轮换着来的，从每个小组的 2 号元素开始，然后下一个小组的 2 号元素
            //这个循环和里面嵌套的循环的作用就是，先拿小组的 2号元素和同一小组进行插入排序
            //当所有小组的 2号元素插入完后，再开始拿 3号元素进行插入排序
            for (int i = gap ; i < arr.length ; i++){

                //这个循环遍历的是小数组：这里遍历的是小数组里的元素
                //j >= 0 避免下标越界
                //arr[j] > arr[j+gap] 当前面的比后面的大，交换才有意义
                for (int j = i - gap ; j >= 0 && arr[j] > arr[j+gap]; j -= gap){
                    tmp = arr[j];
                    arr[j] = arr[j+gap];
                    arr[j+gap] = tmp ;
                }
            }
        }
    }

    /**
     * 希尔排序：移位法
     * 待插入元素依次和前一个元素比较，如果待插入数比较小，将前一个的数据保存到待插入数组位置，继续寻找，直到前面无元素或者比待插入元素小
     * @param arr 源数组
     */
    public static void shellSort2(int[] arr){

        //控制增量
        for (int gap = arr.length / 2 ; gap > 0 ; gap /= 2){
            //从 gap 个元素开始，逐个对其所在数组直接进行插入排序
            for (int i = gap ; i < arr.length ; i++){
                int j = i ;
                int temp = arr[j];
                //待插入元素和前一个比较，如果待插入元素小，进入循环，找到待插入元素位置
                //并且将前一个元素后移一位
                if (arr[j] < arr[j-gap]){
                    while (j - gap >= 0 && temp < arr[j-gap]){
                        //前一个元素后移
                        arr[j] = arr[j-gap];
                        j -= gap;
                    }
                    //退出循环后，j 就是待插入元素的位置
                    arr[j] = temp;
                }
            }
        }
    }

}

```

==注意==：希尔排序的思想 ( 理解 ) 是同组进行插入排序，但是代码实现确实从第一个小组的 2 号元素开始一个个遍历整个数组，而不是先遍历完一整个小数组再去遍历大数组，

**举个例子**：如下图：其中一轮增量，也就是最里面两个 for 循环的作用，不包括最外面控制增量的循环

1. 先取出 1 号小组（黑色）的 2号元素，也就是 1 和同组（黑色）元素进行插入排序，
2. 再取出 2 号小组（蓝色）的 2号元素，也就是 6 和同组（蓝色）元素进行插入排序，
3. 当所有小组的2号元素都遍历插入排序完，
4. 拿出 1 号小组的（黑色）的 3号元素，也就是 0 和同组（黑色）元素进行插入排序
5. 遍历完所有的 3号元素，再拿出 4号元素，依次类推，知道 arr（整个数组）的最后一个元素遍历完
6. 这轮增量循环执行完，执行下一增量

![image-20200902081349867](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20200902081349867.png)







## 6、快速排序

### 1）介绍

​	快速排序（ QuickSort ）是对冒泡排序的一种改进。



### 2）基本思想

​		通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对着两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。



### 3）动图演示

![1](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/1.gif)





### 4）代码实现

```java
package sort;

import java.util.Arrays;

/**
 * 快速排序
 */
public class Quick {
    public static void main(String[] args) {
        int[] arr = Bubbling.getArray(10);
        //int[] arr = {-9,78,0,23,-567,70};
        System.out.println("排序前："+ Arrays.toString(arr));
        long start = System.currentTimeMillis();
        sort(arr,0,arr.length-1);
        System.out.println("花费时间："+(System.currentTimeMillis()-start)+" ms");
        System.out.println("排序后："+ Arrays.toString(arr));

    }

    /**
     * 快速排序算法:第一种实现
     * @param arr 源数组
     * @param left 最左侧下标
     * @param right 最右侧下标
     */
    public static void sort(int[] arr , int left , int right){

        int l = left;
        int r = right;
        int axis = arr[(left + right) / 2]; //中轴数
        int temp; //临时变量

        //当 l >= r时，退出循环
        while (l < r){
            //找出左侧不比中轴数小的数，也就是大于等于中轴数的数
            while (arr[l] < axis){
                l++;
            }

            //找出右侧不比中轴数大的数，也就是等于或者小于中轴数的数
            while (arr[r] > axis){
                r--;
            }

            //当 l >= r 时，左侧已经全是比中轴数小的，右侧全是比中轴数大的
            if (l >= r){
                break;
            }

            //左侧找到不比中轴数小的数，右侧找到不比中轴数大的数
            //两个数交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            //这时候 arr[l] 和 arr[r] 已经交换
            // arr[l] 是之前的右侧数，如果arr[l] 和中轴数相等，r前移，继续循环
            if (arr[l] == axis){
                r--;
            }
            //arr[r] 是之前的左侧数，如果arr[r] 和中轴数相等，l后移，继续循环
            if (arr[r] == axis){
                l++;
            }
            
        }

        //如果 l==r，证明已经找到中间了
        if (l == r){
            l++;
            r--;
        }

        //左递归
        if (left < r){
            sort(arr,left,r);
        }
        if (right > l){
            sort(arr,l,right);
        }

    }

}
```



### 5）代码实现_2

```java
package com.sort;

import java.util.Arrays;

/**
 * 快速排序
 */
public class QuickSort {

    /**
     * 快排
     *
     * @param arr   源数组
     * @param left  左侧下标
     * @param right 右侧下标
     */
    public static void quickSort(int[] arr, int left, int right) {
        if (left > right)
            return;

        // 左右索引
        int l = left;
        int r = right;
        // 基准数
        int standard = arr[left];
        int temp = 0;

        // 循环
        while (l < r) {
            // 1、先从右往左找，找一个比基准数小的
            // 2、再从左往右找，找一个比基准数大的
            while (r > l && arr[r] >= standard)
                r--;
            while (l < r && arr[l] <= standard)
                l++;
            //数值交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;
        }
        // 如果跳出循环，左右两个指针相遇，将相遇位置和基准数交换
        arr[left] = arr[l];
        arr[l] = standard;

        // 这时候，基准数左边的都不比基准数大，右边的不比基准数小
        quickSort(arr, left, l-1);
        quickSort(arr, r+1, right);
    }
}
```



## 7、归并排序



### 1）介绍

​		归并排序（**Merge Sort**）和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n log n) 的时间复杂度。代价是需要额外的内存空间。

​		归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 ( Divide and Conquer ) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2- 路归并。



**最佳情况：T(n) = O(n)  最差情况：T(n) = O(nlogn)  平均情况：T(n) = O(nlogn)**

### 2）算法描述

- 步骤 1：把长度为 n 的输入序列分成两个长度为 n/2 的子序列
- 把这两个子序列分别采用归并排序
- 将两个排序好的子序列合并成一个最终的排序序列。



### 3）动画演示

![img](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm)



### 4）代码实现

```java
package com.sort;

import java.util.Arrays;

/**
 * 归并排序
 */
public class MergeSort {
    /**
     * 归并排序
     *
     * @param array 源数组
     * @return 排序后的数组
     */
    public static int[] mergeSort(int[] array) {
        // 如果数组只有一个元素，没必要排序，直接返回
        if (array.length < 2)
            return array;
        // 将数组对半砍，分为左右两个数组
        int cut = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, cut);
        int[] right = Arrays.copyOfRange(array, cut, array.length);

        // 1、先递归调用当前方法拆分当前数组，拆到数组内只剩一个元素为止
        // 2、数组拆完后，调用排序方法
        return mergeASC(mergeSort(left), mergeSort(right));
    }


    /**
     * 归并排序子模块：排序
     *
     * @param left  左数组
     * @param right 右数组
     * @return
     */
    public static int[] mergeASC(int[] left, int[] right) {
        // 创建一个数组存储排序后的数组，插入法
        int[] result = new int[left.length + right.length];

        // 利用循环逐个向 result 中插入数据
        for (int index = 0, i = 0, j = 0; index < result.length; index++) {
            if (i >= left.length) {
                // left 数组遍历完了，直接插入 right 数组的值
                result[index] = right[j++];
            } else if (j >= right.length) {
                // right 数组遍历完了，直接插入 left 数组的值
                result[index] = left[i++];
            } else if (left[i] > right[j]) {
                // 两个数组都没有遍历完，判断当前两个数组的值大小，将值保存到 result 中
                result[index] = right[j++];
            } else {
                // 两个数组都没有遍历完，判断当前两个数组的值大小，将值保存到 result 中
                result[index] = left[i++];
            }
        }
        return result;
    }
}
```









## 8、基数排序

### 1）介绍

​		基数排序（**Radix Sort**）是一种非比较型整数排序算法，又叫”桶子法“，属于“分配式”排序，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年赫尔曼 · 何乐礼咋打孔片制表机（Tabulation Machine）上的贡献。

​		基数排序会使用到桶（Bucket），顾名思义，通过将要比较的位（个位、十位、百位....）将要排序的元素分配至 0 ~ 9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他比较型的排序法。





### 2）算法步骤

1. 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零
2. 从最低位开始，依次进行一次排序
3. 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列



### 3）基本思想

1. 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成了一个有序序列。



### 4）动画演示

![img](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/基数排序.gif)



### 5）代码实现

```java
package com.sort;


import java.util.*;

/**
 * 基数排序
 */
public class RadixSort {
    /**
     * 基数排序
     *
     * @param arr 源数组
     * @return 排序后的数组
     */
    public static int[] radixSort(int[] arr) {
        if (arr.length < 2)
            return arr;

        // 新建返回数组
        int[] newArr = Arrays.copyOfRange(arr, 0, arr.length);
        // newArr 下标
        int index = 0;
        // 创建10个桶：每个桶长度为 arr 的 1/8
        int[][] bucket = new int[10][arr.length / 8 + 1];
        // 每个桶里的数值个数
        int[] bucketIndex = new int[10];

        // 获取源数组最大值
        int c = 1;
        int max = newArr[0];
        boolean su = true;

        // do while 保证第一遍 max 获取到值
        do {
            // 遍历新数组，并将数保存到桶中
            for (int i = 0; i < newArr.length; i++) {
                int bucketSerial = newArr[i] / c % 10;
                // bucketSerial：i 属于哪个桶
                // bucketIndex[bucketSerial] 当前对应桶中有多少个数，也就是要保存到对应的桶的位置
                if (bucketIndex[bucketSerial] >= bucket[bucketSerial].length) {
                    // 桶内数据过多，桶太小，对该桶扩容，长度为当前长度的两倍
                    System.out.println("扩容：" + bucketSerial);
                    bucket[bucketSerial] = Arrays.copyOf(bucket[bucketSerial], bucket[bucketSerial].length * 2);
                }
                // 获取源数组最大值，su 用来保证只获取一次
                if (su && max < newArr[i]) {
                    max = newArr[i];
                }
                bucket[bucketSerial][bucketIndex[bucketSerial]++] = newArr[i];
            }
            su = false;

            // 取出桶中数据并保存到新数组中
            index = 0;
            for (int j = 0; j < bucket.length; j++) {
                for (int i = 0; i < bucketIndex[j]; i++) {
                    newArr[index++] = bucket[j][i];
                }
                // 取出对应桶中的数据后，将桶内数值归 0
                bucketIndex[j] = 0;
            }
        } while ((c *= 10) <= max);

        return newArr;
    }
}
```









## 9、桶排序

### 1）介绍

**桶排序 (Bucket sort)**或所谓的**箱排序**，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的 排序算法 或是以递归方式继续使用桶排序进行排序）。桶排序是[鸽巢排序](https://baike.baidu.com/item/鸽巢排序/8010555)的一种 归纳 结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间 O(n+k)。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。



### 2）基本思想

1. 将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。
2. 对每个桶内的元素进行排序。可以选择任意一种排序算法。
3.  将各个桶中的元素合并成一个大的有序序列。
4. 假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为 O(n)+O(k)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。







## 10、计数排序

### 1）介绍

计数排序是一个 **非基于比较** 的 排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 [1] 当然这是一种牺牲空间换取时间的做法，而且**当O(k)>O(nog(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(nlog(n))**, 如归并排序，堆排序）





### 2）基本思想

是一种O(n)的排序算法，其思路是开一个长度为 maxValue-minValue+1 的数组，然后

1. 分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。
2. 收集。扫描一遍计数器数组，按顺序把值收集起来。



举个例子， nums=[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值， maxValue=5 , minValue=1 ，于是开一个长度为5的计数器数组 counter ，

1. 分配。统计每个元素出现的频率，得到 counter=[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue=1 出现了2次。
2. 收集。 counter[0]=2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1]=1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。

计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。





## 11、堆排序

### 1）介绍









## 总结

### 1）排序算法的时间和空间复杂度对比

| 排序算法 | 平均时间复杂度 |  最好情况   |  最坏情况   | 空间复杂度 | 排序方式  | 稳定性 |
| :------: | :------------: | :---------: | :---------: | :--------: | :-------: | :----: |
| 冒泡排序 |     O(n²)      |    O(n)     |    O(n²)    |    O(1)    | In-place  |  稳定  |
| 选择排序 |     O(n²)      |    O(n²)    |    O(n²)    |    O(1)    | In-place  | 不稳定 |
| 插入排序 |     O(n²)      |    O(n)     |    O(n²)    |    O(1)    | In-place  |  稳定  |
| 希尔排序 |   O(n log n)   | O(n log² n) | O(n log² n) |    O(1)    | In-place  | 不稳定 |
| 归并排序 |   O(n log n)   | O(n log n)  | O(n log n)  |    O(n)    | out-place |  稳定  |
| 快速排序 |   O(n log n)   | O(n log n)  |    O(n²)    |  O(log n)  | In-place  | 不稳定 |
|  堆排序  |   O(n log n)   | O(n log n)  | O(n log n)  |    O(1)    | In-place  | 不稳定 |
| 计数排序 |     O(n+k)     |   O(n+k)    |   O(n+K)    |    O(k)    | out-place |  稳定  |
|  桶排序  |     O(n+k)     |   O(n+k)    |    O(n²)    |   O(n+k)   | out-plcae |  稳定  |
| 基数排序 |     O(n*k)     |   O(n*k)    |   O(n*k)    |   O(n+k)   | out-place |  稳定  |



### 2）相关术语解释

- n：数据规模
- k：“桶”的个数
- in-place：不占用额外内存
- out-place：占用额外内存



- 稳定：如果 A 原本在 B 前面，而 A=B，排序后 A 仍然在 B 的前面
- 不稳定：如果 A 原本在 B 前面，而 A= B，排序后 A 可能会出现在 B 后面
- 内排序：所有排序操作都在内存中完成
- 外排序：由于数据量过大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
- 时间复杂度：相对来说，一个算法执行完所耗费的时间
- 空间复杂度：运行完一个程序所需要的内存的大小













# 第八章	查找算法



## 1、顺序(线性)查找

### 1. 介绍

顺序查找也叫线性查找



### 2. 思想

从一头找到另一头，一个个对比



### 3.代码实现

```java
/**
  * 线性查找
  * @param arr 源表
  * @param value 需要查找的值
  * @return 找到返回下标，否则返回 -1
  */
public static int getIndex(int[] arr, int value){
    for (int i = 0 ; i < arr.length; i++){
        if (arr[i] == value){
            return i;
        }
    }
    return -1;
}
```





## 2、二分查找

### 1. 介绍

二分查找，顾名思义就是把一个数组分成两份，然后对比中间的数，进行查找



### 2. 使用时需要满足的条件

- 数组需要有序



### 3. 思想

1. 找到中间的下标和需要查找的值进行对比
   1. 假设，数组从小到大排列，
   2. 如果目标数大于中间下标数，目标数可能在中间数右边
   3. 如果目标数小于中间数，目标数可能存在于中间数左边
   4. 如果等于，就直接返回中间数，也就是下标



### 4. 代码实现

#### 1）递归实现

```java
/**
  * 二分查找：递归实现
  *
  * @param arr   源数组
  * @param value 要查找的值
  * @param left  左侧索引
  * @param right 右侧索引
  * @return
  */
public static int getIndex(int[] arr, int value, int left, int rigt){
    // 没找到，返回 -1
    if (left > rigt)
        return -1;

    // 中间数
    int middle = (left+rigt)/2;
    if(value < arr[middle])
        return getIndex(arr,value,left,middle-1);
    else if (value > arr[middle])
        return getIndex(arr,value,middle+1,rigt);

    return middle;
}
```

#### 2）循环实现

```java
/**
  * 二分查找，循环实现
  * @param arr 源数组
  * @param value 需要查找的下标
  * @return
  */
public static int getIndex2(int[] arr, int value) {
    int left = 0;
    int right = arr.length - 1;

    for (; ; ) {
        if (left > right)
            return -1;

        int middle = (left + right) / 2;
        if (value < arr[middle])
            right = middle - 1;
        else if (value > arr[middle])
            left = middle + 1;
        else if(value == arr[middle])
            return middle;
    }
}
```

#### 3）查找多个下标

```java
/**
  * 二分查找，循环实现
  * @param arr 源数组
  * @param value 需要查找的下标
  * @return
  */
public static int getIndex2(int[] arr, int value) {
    int left = 0;
    int right = arr.length - 1;

    for (; ; ) {
        if (left > right)
            return -1;

        int middle = (left + right) / 2;
        if (value < arr[middle])
            right = middle - 1;
        else if (value > arr[middle])
            left = middle + 1;
        else if(value == arr[middle])
            return middle;
    }
}

/**
  * 二分查找：返回的是数组的下标
  * @param arr 源数组
  * @param finVal 需要查找的值
  * @return
  */
public static ArrayList<Integer> getArrIndex(int[] arr, int finVal) {
    if (arr.length < 1 || arr == null)
        return null;

    // resArr 存放结果
    ArrayList list = new ArrayList();
    int resIndex = 0;

    int result = getIndex2(arr, finVal);
    list.add(result);

    int temp = result;
    while (temp > 0 && arr[--temp] == finVal)
        list.add(temp);

    temp = result;
    while (temp < arr.length - 1 && arr[++temp] == finVal)
        list.add(temp);

    return list;
}
```











## 3、差值查找

### 1. 介绍

差值查找说白了就是二分查找的优化而已，二分查找每次都是和中间的比较，而差值查找可以根据需要找的数自适应的偏向，但是如果数组分布不均，差值查找并不一定就比二分查找优秀，甚至还可能出现拖累。



### 2. 使用时需要满足的条件

- 数组有序
- 数组最好是均匀分布的



### 3. 思想

差值查找就是二分查找的优化，如果数组均匀分布的话，可以自适应的偏向需要查找的数而不用向二分查找一样每次对半砍。



**公式**

```java
mid = left + (right - left) * (key - arr[left]) / (arr[right] - arr[left]);
```

![image-20210225152551080](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20210225152551080.png)



### 4. 代码实现

```java
/**
  * 二分查找
  *
  * @param arr 源数组
  * @param key 需要查找的值
  * @return 找到返回下标，否则返回 -1
  */
public static int getIndex(int[] arr, int key) {
    int left = 0;
    int right = arr.length - 1;
    int mid = -1;
    for (; ; ) {
        // 如果数组不正常或者，需要查找的数比数组内最大的大，或者比最小的小，就没有比较的必要了
        if (left > right || key < arr[left] || key > arr[right])
            return -1;

        // 差值查找公式
        mid = left + (right - left) * (key - arr[left]) / (arr[right] - arr[left]);

        // 如果需要查找的数比 arr[mind] 小，缩小右边范围，如果大就缩小左边范围，如果相等就返回。
        if (key < arr[mid])
            right = mid - 1;
        else if (key > arr[mid])
            left = mid + 1;
        else
            return mid;
    }
}
```







## 4、斐波那契查找

### 1. 介绍

斐波那契查找也叫黄金分割法查找，是区间中单峰函数的搜索技术。

斐波那契搜索就是在 **二分查找** 的基础上根据 **斐波那契数列** 进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F[n](如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。



### 2. 使用时需要满足的条件

- 数组有序



### 3. 思想

斐波那契原理与前两种相似，仅仅改变了中间节点 **mid** 的位置，mid 不再是中间或者差值得到，而是位于黄金分割点附近，即 mid = left + F(K-1) -1 

![image-20210225155051651](https://cdn.jsdelivr.net/gh/xinyi1483/image@main/history/image-20210225155051651.png)



**对于 F(k-1)-1 的理解**

1. 由斐波那契数列 F(k) = F(k-1)+F(k-2) 的性质可以得到 ( F(k)-1 ) = ( F(k-1)-1 ) + ( F(k-2)-1 ) +1. 该式说明，只要顺序表的长度为 F(k)-1，则可以将该表分成长度为 F(k-1)-1 和 F(k2)-1 的两段，即如上图所示。从而中间位置为 mid = low + F(k-1) -1
2. 类似的，每一字段可以用相同的方式分割
3. 但顺序表长度 n 不一定刚好等于 F(k) -1，所以需要将原来的顺序表长度 n 增加至 F(k) -1. 这里的 k 值只要能使得 F(k)-1 恰好大于或等于 n 即可，由一下代码得到，顺序表长度增加后，新增的位置 ( 从 n+1 到 F(k)-1 位置 )，都赋为 n 位置的值即可。

```java
while(n > fib(k)-1)
    k++;
```

































































































